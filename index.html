<canvas id="canvas" width="100" height="100" style="image-rendering: pixelated;"></canvas>

<script>
    let WIDTH = 100
    let HEIGHT = 100
    let a = Array(WIDTH * HEIGHT).fill(0)
    a[(HEIGHT/2 - 1) * WIDTH + WIDTH/2] = 1 // center pixel

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    ctx.fillRect(50,50,1,1)
    let bordercolor = ["#FF0000", "#00FF00", "#0000FF", "#FFFF00"]
    
    let ROUNDS = 600
    for(var i=0; i < ROUNDS; i++){
        randomWalk();
    }

    function bounded(min, max, a) {
        let temp = Math.max(min, a)
        return Math.min(temp, max)
    }
    
    function randomWalk() {
        let xmax = WIDTH - 1
        let ymax = HEIGHT - 1
        let x, y
        //choose random border starting place
        let border = Math.floor(Math.random() * 4)
        // 0 is left border, 1 riht border, 2 top border, 3 bottom 
        let start = Math.floor(Math.random() * WIDTH) //Since width == height this works, othrwise need to separate
        if (border == 0 || border == 1) { // left/right
          y = start
          x = border == 0 ? 0 : xmax
        } else { //top-bottom 
            x = start
            y = border == 2 ? 0 : ymax
        }

        let count = 0

        while (a[100*(x) + y] == 0 ) { //not filled
            count++
            //move 1 step. if finds a neighbor, save and draw else continue
            let xd
            let xoff = x - 50 > 0 ? 1 : -1
            xd = Math.random() < 0.52 ? -xoff : xoff // move towards center with probability

            x += xd
            x = bounded(0, WIDTH-1, x)

            if (checkNeighbors(x, y)) {
                a[100*(x-1) + y] = 1
                ctx.fillRect(x,y,1,1)
                return
            }
            let yd
            let yoff = y - 50 > 0 ? 1 : -1
            yd = Math.random() < 0.52 ? -yoff : yoff

            y += yd
            y = bounded(0, HEIGHT-1, y)
            
            //check neighbors and if one is filled, fill this one and be done
            if (checkNeighbors(x, y)) {
                //if (border == 0) {   console.log("found neighbor starting from border 0, is now at " + x + ", " + y)}
                a[100*(x-1) + y] = 1
                //ctx.fillStyle = bordercolor[border]  //different color depending on which border it starts from 
                ctx.fillRect(x,y,1,1)
                return
            }
   
        }

    }
    
    function checkNeighbors(x, y) {
        orig = [x, y]
        o1 = [x-1, y]
        o2 = [x+1, y]

        o3 = [x, y-1]
        o4 = [x, y+1]

        o5 = [x-1, y-1]
        o6 = [x-1, y+1]

        o7 = [x+1, y-1]
        o8 = [x+1, y+1]

        all = [o1, o2, o3, o4, o5, o6, o7, o8] //allowing the last 4 makes diagonal branching, very different. only first 4 - only straight branching

        let valid = all.filter(o => {
            return o[0] < 100 && o[1] < 100 && o[0] >= 0 && o[1] >= 0
        })

        let ret = 0;
        valid.forEach(v => {
            if (a[ 100 * (v[0]-1) + v[1]] == 1) {
                ret = 1
            }
        })
        return ret
    }
    
</script>
