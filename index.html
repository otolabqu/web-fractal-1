<canvas id="canvas" width="100" height="100" style="image-rendering: pixelated;"></canvas>

<script>
    let WIDTH = 100
    let HEIGHT = 100
    let a = Array(WIDTH * HEIGHT).fill(0)
    a[(HEIGHT/2 - 1) * WIDTH + WIDTH/2] = 1 // center pixel

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    ctx.fillRect(50,50,1,1)
    let bordercolor = ["#FF0000", "#00FF00", "#0000FF", "#FFFF00"]
    
    let ROUNDS = 600
    for(var i=0; i < ROUNDS; i++){
        randomWalk();
    }

    function bounded(min, max, a) {
        let temp = Math.max(min, a)
        return Math.min(temp, max)
    }
    
    function off(a, max) { //returns +1 or -1 depending on the distance to center
        let diff = a - max/2
        return diff > 0 ? 1 : -1
    }

    function startposition() {
        let xmax = WIDTH - 1
        let ymax = HEIGHT - 1
        let x, y
        //choose random border starting place
        let border = Math.floor(Math.random() * 4)
        // 0 is left border, 1 riht border, 2 top border, 3 bottom 
        let start = Math.floor(Math.random() * WIDTH) //Since width == height this works, othrwise need to separate
        if (border == 0 || border == 1) { // left/right
          y = start
          x = border == 0 ? 0 : xmax
        } else { //top-bottom 
            x = start
            y = border == 2 ? 0 : ymax
        }
        return [x,y]
    }

    function fillDraw(x, y) {
        a[100*(x-1) + y] = 1
        ctx.fillRect(x,y,1,1)
    }

    function subRandomWalk(n, max) {
        let offset = off(n, max)
        let d = Math.random() < 0.51 ? -offset : offset //move towards center with probability
        return bounded(0, max-1, n+d)
    }

    function randomWalk() {
        let x,y
        let p = startposition()
        x = p[0]
        y = p[1]
        let count = 0

        while (a[100*(x) + y] == 0 ) { //not filled
            //We should choose randomly which direction to move each time. 
            count++
            //move 1 step. if finds a neighbor, save and draw else continue
            x = subRandomWalk(x, WIDTH)

            if (checkNeighbors(x, y)) {
                fillDraw(x,y)
                return
            }

            y = subRandomWalk(y, HEIGHT)

            //check neighbors and if one is filled, fill this one and be done
            if (checkNeighbors(x, y)) {
                fillDraw(x,y)
                return
            }
   
        }

    }
    
    function checkNeighbors(x, y) {
        orig = [x, y]
        o1 = [x-1, y]
        o2 = [x+1, y]

        o3 = [x, y-1]
        o4 = [x, y+1]

        o5 = [x-1, y-1]
        o6 = [x-1, y+1]

        o7 = [x+1, y-1]
        o8 = [x+1, y+1]

        all = [o1, o2, o3, o4, o5, o6, o7, o8] //allowing the last 4 makes diagonal branching, very different. only first 4 - only straight branching

        let valid = all.filter(o => {
            return o[0] < 100 && o[1] < 100 && o[0] >= 0 && o[1] >= 0
        })

        let ret = 0;
        valid.forEach(v => {
            if (a[ 100 * (v[0]-1) + v[1]] == 1) {
                ret = 1
            }
        })
        return ret
    }
    
</script>
